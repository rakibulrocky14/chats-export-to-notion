var background = (function() {
    "use strict";
    function Be(t) {
        return t == null || typeof t == "function" ? {
            main: t
        } : t
    }
    const p = globalThis.browser?.runtime?.id ? globalThis.browser : globalThis.chrome;
    function Ae(t) {
        return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
    }
    var H = {
        exports: {}
    }, ye;
    function He() {
        if (ye)
            return H.exports;
        ye = 1;
        const t = r => typeof crypto < "u" && typeof crypto.getRandomValues == "function" ? () => {
            const s = crypto.getRandomValues(new Uint8Array(1))[0];
            return (s >= r ? s % r : s).toString(r)
        }
        : () => Math.floor(Math.random() * r).toString(r)
          , e = (r=7, s=!1) => Array.from({
            length: r
        }, t(s ? 16 : 36)).join("");
        return H.exports = e,
        H.exports.default = e,
        H.exports
    }
    var We = He();
    const W = Ae(We);
    var ze = () => `uid::${W(7)}`
      , Je = (t, e=["endpointName", "fingerprint"]) => typeof t == "object" && t !== null && e.every(r => r in t)
      , Ge = t => {
        try {
            const e = JSON.parse(t);
            return Je(e) ? e : null
        } catch {
            return null
        }
    }
      , Ve = () => {
        let t = [];
        return {
            add: (...e) => {
                t = [...t, ...e]
            }
            ,
            remove: e => {
                t = typeof e == "string" ? t.filter(r => r.message.transactionId !== e) : t.filter(r => !e.includes(r))
            }
            ,
            entries: () => t
        }
    }
      , q = class {
        static toBackground(t, e) {
            return t.postMessage(e)
        }
        static toExtensionContext(t, e) {
            return t.postMessage(e)
        }
    }
      , Xe = Object.defineProperty
      , Ze = Object.defineProperties
      , Ye = Object.getOwnPropertyDescriptors
      , be = Object.getOwnPropertySymbols
      , Ke = Object.prototype.hasOwnProperty
      , Qe = Object.prototype.propertyIsEnumerable
      , we = (t, e, r) => e in t ? Xe(t, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: r
    }) : t[e] = r
      , I = (t, e) => {
        for (var r in e || (e = {}))
            Ke.call(e, r) && we(t, r, e[r]);
        if (be)
            for (var r of be(e))
                Qe.call(e, r) && we(t, r, e[r]);
        return t
    }
      , ne = (t, e) => Ze(t, Ye(e))
      , et = /^((?:background$)|devtools|popup|options|content-script|window)(?:@(\d+)(?:\.(\d+))?)?$/
      , oe = t => {
        const [,e,r,s] = t.match(et) || [];
        return {
            context: e,
            tabId: +r,
            frameId: s ? +s : void 0
        }
    }
      , z = ({context: t, tabId: e, frameId: r}) => ["background", "popup", "options"].includes(t) ? t : `${t}@${e}${r ? `.${r}` : ""}`;
    const tt = [{
        property: "name",
        enumerable: !1
    }, {
        property: "message",
        enumerable: !1
    }, {
        property: "stack",
        enumerable: !1
    }, {
        property: "code",
        enumerable: !0
    }]
      , ie = Symbol(".toJSON was called")
      , rt = t => {
        t[ie] = !0;
        const e = t.toJSON();
        return delete t[ie],
        e
    }
      , xe = ({from: t, seen: e, to_: r, forceEnumerable: s, maxDepth: n, depth: o}) => {
        const i = r || (Array.isArray(t) ? [] : {});
        if (e.push(t),
        o >= n)
            return i;
        if (typeof t.toJSON == "function" && t[ie] !== !0)
            return rt(t);
        for (const [a,c] of Object.entries(t)) {
            if (typeof Buffer == "function" && Buffer.isBuffer(c)) {
                i[a] = "[object Buffer]";
                continue
            }
            if (c !== null && typeof c == "object" && typeof c.pipe == "function") {
                i[a] = "[object Stream]";
                continue
            }
            if (typeof c != "function") {
                if (!c || typeof c != "object") {
                    i[a] = c;
                    continue
                }
                if (!e.includes(t[a])) {
                    o++,
                    i[a] = xe({
                        from: t[a],
                        seen: [...e],
                        forceEnumerable: s,
                        maxDepth: n,
                        depth: o
                    });
                    continue
                }
                i[a] = "[Circular]"
            }
        }
        for (const {property: a, enumerable: c} of tt)
            typeof t[a] == "string" && Object.defineProperty(i, a, {
                value: t[a],
                enumerable: !0,
                configurable: !0,
                writable: !0
            });
        return i
    }
    ;
    function st(t, e={}) {
        const {maxDepth: r=Number.POSITIVE_INFINITY} = e;
        return typeof t == "object" && t !== null ? xe({
            from: t,
            seen: [],
            forceEnumerable: !0,
            maxDepth: r,
            depth: 0
        }) : typeof t == "function" ? `[Function: ${t.name || "anonymous"}]` : t
    }
    let Te = () => ({
        events: {},
        emit(t, ...e) {
            (this.events[t] || []).forEach(r => r(...e))
        },
        on(t, e) {
            return (this.events[t] = this.events[t] || []).push(e),
            () => this.events[t] = (this.events[t] || []).filter(r => r !== e)
        }
    });
    var nt = (t, e, r) => {
        const s = W()
          , n = new Map
          , o = new Map
          , i = a => {
            if (a.destination.context === t && !a.destination.frameId && !a.destination.tabId) {
                r?.(a);
                const {transactionId: c, messageID: u, messageType: h} = a
                  , E = () => {
                    const w = n.get(c);
                    if (w) {
                        const {err: A, data: R} = a;
                        if (A) {
                            const T = A
                              , se = self[T.name]
                              , $ = new (typeof se == "function" ? se : Error)(T.message);
                            for (const F in T)
                                $[F] = T[F];
                            w.reject($)
                        } else
                            w.resolve(R);
                        n.delete(c)
                    }
                }
                  , P = async () => {
                    let w, A, R = !1;
                    try {
                        const T = o.get(u);
                        if (typeof T == "function")
                            w = await T({
                                sender: a.origin,
                                id: u,
                                data: a.data,
                                timestamp: a.timestamp
                            });
                        else
                            throw R = !0,
                            new Error(`[webext-bridge] No handler registered in '${t}' to accept messages with id '${u}'`)
                    } catch (T) {
                        A = T
                    } finally {
                        if (A && (a.err = st(A)),
                        i(ne(I({}, a), {
                            messageType: "reply",
                            data: w,
                            origin: {
                                context: t,
                                tabId: null
                            },
                            destination: a.origin,
                            hops: []
                        })),
                        A && !R)
                            throw w
                    }
                }
                ;
                switch (h) {
                case "reply":
                    return E();
                case "message":
                    return P()
                }
            }
            return a.hops.push(`${t}::${s}`),
            e(a)
        }
        ;
        return {
            handleMessage: i,
            endTransaction: a => {
                const c = n.get(a);
                c?.reject("Transaction was ended before it could complete"),
                n.delete(a)
            }
            ,
            sendMessage: (a, c, u="background") => {
                const h = typeof u == "string" ? oe(u) : u
                  , E = "Bridge#sendMessage ->";
                if (!h.context)
                    throw new TypeError(`${E} Destination must be any one of known destinations`);
                return new Promise( (P, w) => {
                    const A = {
                        messageID: a,
                        data: c,
                        destination: h,
                        messageType: "message",
                        transactionId: W(),
                        origin: {
                            context: t,
                            tabId: null
                        },
                        hops: [],
                        timestamp: Date.now()
                    };
                    n.set(A.transactionId, {
                        resolve: P,
                        reject: w
                    });
                    try {
                        i(A)
                    } catch (R) {
                        n.delete(A.transactionId),
                        w(R)
                    }
                }
                )
            }
            ,
            onMessage: (a, c) => (o.set(a, c),
            () => o.delete(a))
        }
    }
      , N = class {
        constructor(t, e) {
            this.endpointRuntime = t,
            this.streamInfo = e,
            this.emitter = Te(),
            this.isClosed = !1,
            this.handleStreamClose = () => {
                this.isClosed || (this.isClosed = !0,
                this.emitter.emit("closed", !0),
                this.emitter.events = {})
            }
            ,
            N.initDone || (t.onMessage("__crx_bridge_stream_transfer__", r => {
                const {streamId: s, streamTransfer: n, action: o} = r.data
                  , i = N.openStreams.get(s);
                i && !i.isClosed && (o === "transfer" && i.emitter.emit("message", n),
                o === "close" && (N.openStreams.delete(s),
                i.handleStreamClose()))
            }
            ),
            N.initDone = !0),
            N.openStreams.set(this.streamInfo.streamId, this)
        }
        get info() {
            return this.streamInfo
        }
        send(t) {
            if (this.isClosed)
                throw new Error("Attempting to send a message over closed stream. Use stream.onClose(<callback>) to keep an eye on stream status");
            this.endpointRuntime.sendMessage("__crx_bridge_stream_transfer__", {
                streamId: this.streamInfo.streamId,
                streamTransfer: t,
                action: "transfer"
            }, this.streamInfo.endpoint)
        }
        close(t) {
            t && this.send(t),
            this.handleStreamClose(),
            this.endpointRuntime.sendMessage("__crx_bridge_stream_transfer__", {
                streamId: this.streamInfo.streamId,
                streamTransfer: null,
                action: "close"
            }, this.streamInfo.endpoint)
        }
        onMessage(t) {
            return this.getDisposable("message", t)
        }
        onClose(t) {
            return this.getDisposable("closed", t)
        }
        getDisposable(t, e) {
            const r = this.emitter.on(t, e);
            return Object.assign(r, {
                dispose: r,
                close: r
            })
        }
    }
      , J = N;
    J.initDone = !1,
    J.openStreams = new Map;
    var ot = t => {
        const e = new Map
          , r = new Map
          , s = Te();
        t.onMessage("__crx_bridge_stream_open__", i => new Promise(a => {
            const {sender: c, data: u} = i
              , {channel: h} = u;
            let E = !1
              , P = () => {}
            ;
            const w = () => {
                const A = r.get(h);
                typeof A == "function" ? (A(new J(t,ne(I({}, u), {
                    endpoint: c
                }))),
                E && P(),
                a(!0)) : E || (E = !0,
                P = s.on("did-change-stream-callbacks", w))
            }
            ;
            w()
        }
        ));
        async function n(i, a) {
            if (e.has(i))
                throw new Error("webext-bridge: A Stream is already open at this channel");
            const c = typeof a == "string" ? oe(a) : a
              , u = {
                streamId: W(),
                channel: i,
                endpoint: c
            }
              , h = new J(t,u);
            return h.onClose( () => e.delete(i)),
            await t.sendMessage("__crx_bridge_stream_open__", u, c),
            e.set(i, h),
            h
        }
        function o(i, a) {
            if (r.has(i))
                throw new Error("webext-bridge: This channel has already been claimed. Stream allows only one-on-one communication");
            r.set(i, a),
            s.emit("did-change-stream-callbacks")
        }
        return {
            openStream: n,
            onOpenStreamChannel: o
        }
    }
    , G = {
        exports: {}
    }, it = G.exports, ve;
    function at() {
        return ve || (ve = 1,
        (function(t, e) {
            (function(r, s) {
                s(t)
            }
            )(typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : it, function(r) {
                if (typeof globalThis != "object" || typeof chrome != "object" || !chrome || !chrome.runtime || !chrome.runtime.id)
                    throw new Error("This script should only be loaded in a browser extension.");
                if (typeof globalThis.browser > "u" || Object.getPrototypeOf(globalThis.browser) !== Object.prototype) {
                    const s = "The message port closed before a response was received."
                      , n = "Returning a Promise is the preferred way to send a reply from an onMessage/onMessageExternal listener, as the sendResponse will be removed from the specs (See https://developer.mozilla.org/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage)"
                      , o = i => {
                        const a = {
                            alarms: {
                                clear: {
                                    minArgs: 0,
                                    maxArgs: 1
                                },
                                clearAll: {
                                    minArgs: 0,
                                    maxArgs: 0
                                },
                                get: {
                                    minArgs: 0,
                                    maxArgs: 1
                                },
                                getAll: {
                                    minArgs: 0,
                                    maxArgs: 0
                                }
                            },
                            bookmarks: {
                                create: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                get: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                getChildren: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                getRecent: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                getSubTree: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                getTree: {
                                    minArgs: 0,
                                    maxArgs: 0
                                },
                                move: {
                                    minArgs: 2,
                                    maxArgs: 2
                                },
                                remove: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                removeTree: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                search: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                update: {
                                    minArgs: 2,
                                    maxArgs: 2
                                }
                            },
                            browserAction: {
                                disable: {
                                    minArgs: 0,
                                    maxArgs: 1,
                                    fallbackToNoCallback: !0
                                },
                                enable: {
                                    minArgs: 0,
                                    maxArgs: 1,
                                    fallbackToNoCallback: !0
                                },
                                getBadgeBackgroundColor: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                getBadgeText: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                getPopup: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                getTitle: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                openPopup: {
                                    minArgs: 0,
                                    maxArgs: 0
                                },
                                setBadgeBackgroundColor: {
                                    minArgs: 1,
                                    maxArgs: 1,
                                    fallbackToNoCallback: !0
                                },
                                setBadgeText: {
                                    minArgs: 1,
                                    maxArgs: 1,
                                    fallbackToNoCallback: !0
                                },
                                setIcon: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                setPopup: {
                                    minArgs: 1,
                                    maxArgs: 1,
                                    fallbackToNoCallback: !0
                                },
                                setTitle: {
                                    minArgs: 1,
                                    maxArgs: 1,
                                    fallbackToNoCallback: !0
                                }
                            },
                            browsingData: {
                                remove: {
                                    minArgs: 2,
                                    maxArgs: 2
                                },
                                removeCache: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                removeCookies: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                removeDownloads: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                removeFormData: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                removeHistory: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                removeLocalStorage: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                removePasswords: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                removePluginData: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                settings: {
                                    minArgs: 0,
                                    maxArgs: 0
                                }
                            },
                            commands: {
                                getAll: {
                                    minArgs: 0,
                                    maxArgs: 0
                                }
                            },
                            contextMenus: {
                                remove: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                removeAll: {
                                    minArgs: 0,
                                    maxArgs: 0
                                },
                                update: {
                                    minArgs: 2,
                                    maxArgs: 2
                                }
                            },
                            cookies: {
                                get: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                getAll: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                getAllCookieStores: {
                                    minArgs: 0,
                                    maxArgs: 0
                                },
                                remove: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                set: {
                                    minArgs: 1,
                                    maxArgs: 1
                                }
                            },
                            devtools: {
                                inspectedWindow: {
                                    eval: {
                                        minArgs: 1,
                                        maxArgs: 2,
                                        singleCallbackArg: !1
                                    }
                                },
                                panels: {
                                    create: {
                                        minArgs: 3,
                                        maxArgs: 3,
                                        singleCallbackArg: !0
                                    },
                                    elements: {
                                        createSidebarPane: {
                                            minArgs: 1,
                                            maxArgs: 1
                                        }
                                    }
                                }
                            },
                            downloads: {
                                cancel: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                download: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                erase: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                getFileIcon: {
                                    minArgs: 1,
                                    maxArgs: 2
                                },
                                open: {
                                    minArgs: 1,
                                    maxArgs: 1,
                                    fallbackToNoCallback: !0
                                },
                                pause: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                removeFile: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                resume: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                search: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                show: {
                                    minArgs: 1,
                                    maxArgs: 1,
                                    fallbackToNoCallback: !0
                                }
                            },
                            extension: {
                                isAllowedFileSchemeAccess: {
                                    minArgs: 0,
                                    maxArgs: 0
                                },
                                isAllowedIncognitoAccess: {
                                    minArgs: 0,
                                    maxArgs: 0
                                }
                            },
                            history: {
                                addUrl: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                deleteAll: {
                                    minArgs: 0,
                                    maxArgs: 0
                                },
                                deleteRange: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                deleteUrl: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                getVisits: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                search: {
                                    minArgs: 1,
                                    maxArgs: 1
                                }
                            },
                            i18n: {
                                detectLanguage: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                getAcceptLanguages: {
                                    minArgs: 0,
                                    maxArgs: 0
                                }
                            },
                            identity: {
                                launchWebAuthFlow: {
                                    minArgs: 1,
                                    maxArgs: 1
                                }
                            },
                            idle: {
                                queryState: {
                                    minArgs: 1,
                                    maxArgs: 1
                                }
                            },
                            management: {
                                get: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                getAll: {
                                    minArgs: 0,
                                    maxArgs: 0
                                },
                                getSelf: {
                                    minArgs: 0,
                                    maxArgs: 0
                                },
                                setEnabled: {
                                    minArgs: 2,
                                    maxArgs: 2
                                },
                                uninstallSelf: {
                                    minArgs: 0,
                                    maxArgs: 1
                                }
                            },
                            notifications: {
                                clear: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                create: {
                                    minArgs: 1,
                                    maxArgs: 2
                                },
                                getAll: {
                                    minArgs: 0,
                                    maxArgs: 0
                                },
                                getPermissionLevel: {
                                    minArgs: 0,
                                    maxArgs: 0
                                },
                                update: {
                                    minArgs: 2,
                                    maxArgs: 2
                                }
                            },
                            pageAction: {
                                getPopup: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                getTitle: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                hide: {
                                    minArgs: 1,
                                    maxArgs: 1,
                                    fallbackToNoCallback: !0
                                },
                                setIcon: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                setPopup: {
                                    minArgs: 1,
                                    maxArgs: 1,
                                    fallbackToNoCallback: !0
                                },
                                setTitle: {
                                    minArgs: 1,
                                    maxArgs: 1,
                                    fallbackToNoCallback: !0
                                },
                                show: {
                                    minArgs: 1,
                                    maxArgs: 1,
                                    fallbackToNoCallback: !0
                                }
                            },
                            permissions: {
                                contains: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                getAll: {
                                    minArgs: 0,
                                    maxArgs: 0
                                },
                                remove: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                request: {
                                    minArgs: 1,
                                    maxArgs: 1
                                }
                            },
                            runtime: {
                                getBackgroundPage: {
                                    minArgs: 0,
                                    maxArgs: 0
                                },
                                getPlatformInfo: {
                                    minArgs: 0,
                                    maxArgs: 0
                                },
                                openOptionsPage: {
                                    minArgs: 0,
                                    maxArgs: 0
                                },
                                requestUpdateCheck: {
                                    minArgs: 0,
                                    maxArgs: 0
                                },
                                sendMessage: {
                                    minArgs: 1,
                                    maxArgs: 3
                                },
                                sendNativeMessage: {
                                    minArgs: 2,
                                    maxArgs: 2
                                },
                                setUninstallURL: {
                                    minArgs: 1,
                                    maxArgs: 1
                                }
                            },
                            sessions: {
                                getDevices: {
                                    minArgs: 0,
                                    maxArgs: 1
                                },
                                getRecentlyClosed: {
                                    minArgs: 0,
                                    maxArgs: 1
                                },
                                restore: {
                                    minArgs: 0,
                                    maxArgs: 1
                                }
                            },
                            storage: {
                                local: {
                                    clear: {
                                        minArgs: 0,
                                        maxArgs: 0
                                    },
                                    get: {
                                        minArgs: 0,
                                        maxArgs: 1
                                    },
                                    getBytesInUse: {
                                        minArgs: 0,
                                        maxArgs: 1
                                    },
                                    remove: {
                                        minArgs: 1,
                                        maxArgs: 1
                                    },
                                    set: {
                                        minArgs: 1,
                                        maxArgs: 1
                                    }
                                },
                                managed: {
                                    get: {
                                        minArgs: 0,
                                        maxArgs: 1
                                    },
                                    getBytesInUse: {
                                        minArgs: 0,
                                        maxArgs: 1
                                    }
                                },
                                sync: {
                                    clear: {
                                        minArgs: 0,
                                        maxArgs: 0
                                    },
                                    get: {
                                        minArgs: 0,
                                        maxArgs: 1
                                    },
                                    getBytesInUse: {
                                        minArgs: 0,
                                        maxArgs: 1
                                    },
                                    remove: {
                                        minArgs: 1,
                                        maxArgs: 1
                                    },
                                    set: {
                                        minArgs: 1,
                                        maxArgs: 1
                                    }
                                }
                            },
                            tabs: {
                                captureVisibleTab: {
                                    minArgs: 0,
                                    maxArgs: 2
                                },
                                create: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                detectLanguage: {
                                    minArgs: 0,
                                    maxArgs: 1
                                },
                                discard: {
                                    minArgs: 0,
                                    maxArgs: 1
                                },
                                duplicate: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                executeScript: {
                                    minArgs: 1,
                                    maxArgs: 2
                                },
                                get: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                getCurrent: {
                                    minArgs: 0,
                                    maxArgs: 0
                                },
                                getZoom: {
                                    minArgs: 0,
                                    maxArgs: 1
                                },
                                getZoomSettings: {
                                    minArgs: 0,
                                    maxArgs: 1
                                },
                                goBack: {
                                    minArgs: 0,
                                    maxArgs: 1
                                },
                                goForward: {
                                    minArgs: 0,
                                    maxArgs: 1
                                },
                                highlight: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                insertCSS: {
                                    minArgs: 1,
                                    maxArgs: 2
                                },
                                move: {
                                    minArgs: 2,
                                    maxArgs: 2
                                },
                                query: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                reload: {
                                    minArgs: 0,
                                    maxArgs: 2
                                },
                                remove: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                removeCSS: {
                                    minArgs: 1,
                                    maxArgs: 2
                                },
                                sendMessage: {
                                    minArgs: 2,
                                    maxArgs: 3
                                },
                                setZoom: {
                                    minArgs: 1,
                                    maxArgs: 2
                                },
                                setZoomSettings: {
                                    minArgs: 1,
                                    maxArgs: 2
                                },
                                update: {
                                    minArgs: 1,
                                    maxArgs: 2
                                }
                            },
                            topSites: {
                                get: {
                                    minArgs: 0,
                                    maxArgs: 0
                                }
                            },
                            webNavigation: {
                                getAllFrames: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                getFrame: {
                                    minArgs: 1,
                                    maxArgs: 1
                                }
                            },
                            webRequest: {
                                handlerBehaviorChanged: {
                                    minArgs: 0,
                                    maxArgs: 0
                                }
                            },
                            windows: {
                                create: {
                                    minArgs: 0,
                                    maxArgs: 1
                                },
                                get: {
                                    minArgs: 1,
                                    maxArgs: 2
                                },
                                getAll: {
                                    minArgs: 0,
                                    maxArgs: 1
                                },
                                getCurrent: {
                                    minArgs: 0,
                                    maxArgs: 1
                                },
                                getLastFocused: {
                                    minArgs: 0,
                                    maxArgs: 1
                                },
                                remove: {
                                    minArgs: 1,
                                    maxArgs: 1
                                },
                                update: {
                                    minArgs: 2,
                                    maxArgs: 2
                                }
                            }
                        };
                        if (Object.keys(a).length === 0)
                            throw new Error("api-metadata.json has not been included in browser-polyfill");
                        class c extends WeakMap {
                            constructor(g, f=void 0) {
                                super(f),
                                this.createItem = g
                            }
                            get(g) {
                                return this.has(g) || this.set(g, this.createItem(g)),
                                super.get(g)
                            }
                        }
                        const u = l => l && typeof l == "object" && typeof l.then == "function"
                          , h = (l, g) => (...f) => {
                            i.runtime.lastError ? l.reject(new Error(i.runtime.lastError.message)) : g.singleCallbackArg || f.length <= 1 && g.singleCallbackArg !== !1 ? l.resolve(f[0]) : l.resolve(f)
                        }
                          , E = l => l == 1 ? "argument" : "arguments"
                          , P = (l, g) => function(m, ...b) {
                            if (b.length < g.minArgs)
                                throw new Error(`Expected at least ${g.minArgs} ${E(g.minArgs)} for ${l}(), got ${b.length}`);
                            if (b.length > g.maxArgs)
                                throw new Error(`Expected at most ${g.maxArgs} ${E(g.maxArgs)} for ${l}(), got ${b.length}`);
                            return new Promise( (v, S) => {
                                if (g.fallbackToNoCallback)
                                    try {
                                        m[l](...b, h({
                                            resolve: v,
                                            reject: S
                                        }, g))
                                    } catch (d) {
                                        console.warn(`${l} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `, d),
                                        m[l](...b),
                                        g.fallbackToNoCallback = !1,
                                        g.noCallback = !0,
                                        v()
                                    }
                                else
                                    g.noCallback ? (m[l](...b),
                                    v()) : m[l](...b, h({
                                        resolve: v,
                                        reject: S
                                    }, g))
                            }
                            )
                        }
                          , w = (l, g, f) => new Proxy(g,{
                            apply(m, b, v) {
                                return f.call(b, l, ...v)
                            }
                        });
                        let A = Function.call.bind(Object.prototype.hasOwnProperty);
                        const R = (l, g={}, f={}) => {
                            let m = Object.create(null)
                              , b = {
                                has(S, d) {
                                    return d in l || d in m
                                },
                                get(S, d, k) {
                                    if (d in m)
                                        return m[d];
                                    if (!(d in l))
                                        return;
                                    let y = l[d];
                                    if (typeof y == "function")
                                        if (typeof g[d] == "function")
                                            y = w(l, l[d], g[d]);
                                        else if (A(f, d)) {
                                            let D = P(d, f[d]);
                                            y = w(l, l[d], D)
                                        } else
                                            y = y.bind(l);
                                    else if (typeof y == "object" && y !== null && (A(g, d) || A(f, d)))
                                        y = R(y, g[d], f[d]);
                                    else if (A(f, "*"))
                                        y = R(y, g[d], f["*"]);
                                    else
                                        return Object.defineProperty(m, d, {
                                            configurable: !0,
                                            enumerable: !0,
                                            get() {
                                                return l[d]
                                            },
                                            set(D) {
                                                l[d] = D
                                            }
                                        }),
                                        y;
                                    return m[d] = y,
                                    y
                                },
                                set(S, d, k, y) {
                                    return d in m ? m[d] = k : l[d] = k,
                                    !0
                                },
                                defineProperty(S, d, k) {
                                    return Reflect.defineProperty(m, d, k)
                                },
                                deleteProperty(S, d) {
                                    return Reflect.deleteProperty(m, d)
                                }
                            }
                              , v = Object.create(l);
                            return new Proxy(v,b)
                        }
                          , T = l => ({
                            addListener(g, f, ...m) {
                                g.addListener(l.get(f), ...m)
                            },
                            hasListener(g, f) {
                                return g.hasListener(l.get(f))
                            },
                            removeListener(g, f) {
                                g.removeListener(l.get(f))
                            }
                        })
                          , se = new c(l => typeof l != "function" ? l : function(f) {
                            const m = R(f, {}, {
                                getContent: {
                                    minArgs: 0,
                                    maxArgs: 0
                                }
                            });
                            l(m)
                        }
                        );
                        let $ = !1;
                        const F = new c(l => typeof l != "function" ? l : function(f, m, b) {
                            let v = !1, S, d = new Promise(B => {
                                S = function(_) {
                                    $ || (console.warn(n, new Error().stack),
                                    $ = !0),
                                    v = !0,
                                    B(_)
                                }
                            }
                            ), k;
                            try {
                                k = l(f, m, S)
                            } catch (B) {
                                k = Promise.reject(B)
                            }
                            const y = k !== !0 && u(k);
                            if (k !== !0 && !y && !v)
                                return !1;
                            const D = B => {
                                B.then(_ => {
                                    b(_)
                                }
                                , _ => {
                                    let pe;
                                    _ && (_ instanceof Error || typeof _.message == "string") ? pe = _.message : pe = "An unexpected error occurred",
                                    b({
                                        __mozWebExtensionPolyfillReject__: !0,
                                        message: pe
                                    })
                                }
                                ).catch(_ => {
                                    console.error("Failed to send onMessage rejected reply", _)
                                }
                                )
                            }
                            ;
                            return D(y ? k : d),
                            !0
                        }
                        )
                          , Gt = ({reject: l, resolve: g}, f) => {
                            i.runtime.lastError ? i.runtime.lastError.message === s ? g() : l(new Error(i.runtime.lastError.message)) : f && f.__mozWebExtensionPolyfillReject__ ? l(new Error(f.message)) : g(f)
                        }
                          , Fe = (l, g, f, ...m) => {
                            if (m.length < g.minArgs)
                                throw new Error(`Expected at least ${g.minArgs} ${E(g.minArgs)} for ${l}(), got ${m.length}`);
                            if (m.length > g.maxArgs)
                                throw new Error(`Expected at most ${g.maxArgs} ${E(g.maxArgs)} for ${l}(), got ${m.length}`);
                            return new Promise( (b, v) => {
                                const S = Gt.bind(null, {
                                    resolve: b,
                                    reject: v
                                });
                                m.push(S),
                                f.sendMessage(...m)
                            }
                            )
                        }
                          , Vt = {
                            devtools: {
                                network: {
                                    onRequestFinished: T(se)
                                }
                            },
                            runtime: {
                                onMessage: T(F),
                                onMessageExternal: T(F),
                                sendMessage: Fe.bind(null, "sendMessage", {
                                    minArgs: 1,
                                    maxArgs: 3
                                })
                            },
                            tabs: {
                                sendMessage: Fe.bind(null, "sendMessage", {
                                    minArgs: 2,
                                    maxArgs: 3
                                })
                            }
                        }
                          , he = {
                            clear: {
                                minArgs: 1,
                                maxArgs: 1
                            },
                            get: {
                                minArgs: 1,
                                maxArgs: 1
                            },
                            set: {
                                minArgs: 1,
                                maxArgs: 1
                            }
                        };
                        return a.privacy = {
                            network: {
                                "*": he
                            },
                            services: {
                                "*": he
                            },
                            websites: {
                                "*": he
                            }
                        },
                        R(i, Vt, a)
                    }
                    ;
                    r.exports = o(chrome)
                } else
                    r.exports = globalThis.browser
            })
        }
        )(G)),
        G.exports
    }
    var ct = at();
    const lt = Ae(ct);
    var j = Ve()
      , x = new Map
      , O = new Map
      , V = new Map
      , Ee = (t, e) => (O.set(t, (O.get(t) || new Set).add(e)),
    () => {
        const r = O.get(t);
        r?.delete(e) && r?.size === 0 && O.delete(t)
    }
    )
      , Se = (t, e) => {
        V.set(t, (V.get(t) || new Set).add(e))
    }
      , C = t => ({
        withFingerprint: e => {
            const r = n => ({
                and: () => n
            })
              , s = {
                aboutIncomingMessage: n => {
                    const o = x.get(t);
                    return q.toExtensionContext(o.port, {
                        status: "incoming",
                        message: n
                    }),
                    r(s)
                }
                ,
                aboutSuccessfulDelivery: n => {
                    const o = x.get(t);
                    return q.toExtensionContext(o.port, {
                        status: "delivered",
                        receipt: n
                    }),
                    r(s)
                }
                ,
                aboutMessageUndeliverability: (n, o) => {
                    const i = x.get(t);
                    return i?.fingerprint === e && q.toExtensionContext(i.port, {
                        status: "undeliverable",
                        resolvedDestination: n,
                        message: o
                    }),
                    r(s)
                }
                ,
                whenDeliverableTo: n => {
                    const o = () => {
                        const i = x.get(t);
                        if (i?.fingerprint === e && x.has(n))
                            return q.toExtensionContext(i.port, {
                                status: "deliverable",
                                deliverableTo: n
                            }),
                            !0
                    }
                    ;
                    if (!o()) {
                        const i = Ee(n, o);
                        Se(e, i)
                    }
                    return r(s)
                }
                ,
                aboutSessionEnded: n => {
                    const o = x.get(t);
                    return o?.fingerprint === e && q.toExtensionContext(o.port, {
                        status: "terminated",
                        fingerprint: n
                    }),
                    r(s)
                }
            };
            return s
        }
    })
      , ut = ze()
      , X = nt("background", t => {
        var e;
        if (t.origin.context === "background" && ["content-script", "devtools "].includes(t.destination.context) && !t.destination.tabId)
            throw new TypeError("When sending messages from background page, use @tabId syntax to target specific tab");
        const r = z(I(I({}, t.origin), t.origin.context === "window" && {
            context: "content-script"
        }))
          , s = z(ne(I(I({}, t.destination), t.destination.context === "window" && {
            context: "content-script"
        }), {
            tabId: t.destination.tabId || t.origin.tabId
        }));
        t.destination.tabId = null,
        t.destination.frameId = null;
        const n = () => x.get(s)
          , o = () => x.get(r)
          , i = () => {
            var a;
            C(s).withFingerprint(n().fingerprint).aboutIncomingMessage(t);
            const c = {
                message: t,
                to: n().fingerprint,
                from: {
                    endpointId: r,
                    fingerprint: (a = o()) == null ? void 0 : a.fingerprint
                }
            };
            t.messageType === "message" && j.add(c),
            t.messageType === "reply" && j.remove(t.messageID),
            o() && C(r).withFingerprint(o().fingerprint).aboutSuccessfulDelivery(c)
        }
        ;
        (e = n()) != null && e.port ? i() : t.messageType === "message" && (t.origin.context === "background" ? Ee(s, i) : o() && C(r).withFingerprint(o().fingerprint).aboutMessageUndeliverability(s, t).and().whenDeliverableTo(s))
    }
    , t => {
        const e = z(I(I({}, t.origin), t.origin.context === "window" && {
            context: "content-script"
        }))
          , r = x.get(e)
          , s = {
            message: t,
            to: ut,
            from: {
                endpointId: e,
                fingerprint: r.fingerprint
            }
        };
        C(e).withFingerprint(r.fingerprint).aboutSuccessfulDelivery(s)
    }
    );
    lt.runtime.onConnect.addListener(t => {
        var e;
        const r = Ge(t.name);
        if (!r)
            return;
        r.endpointName || (r.endpointName = z({
            context: "content-script",
            tabId: t.sender.tab.id,
            frameId: t.sender.frameId
        }));
        const {tabId: s, frameId: n} = oe(r.endpointName);
        x.set(r.endpointName, {
            fingerprint: r.fingerprint,
            port: t
        }),
        (e = O.get(r.endpointName)) == null || e.forEach(o => o()),
        O.delete(r.endpointName),
        Se(r.fingerprint, () => {
            const o = j.entries().filter(i => i.to === r.fingerprint);
            j.remove(o),
            o.forEach(i => {
                i.from.endpointId === "background" ? X.endTransaction(i.message.transactionId) : C(i.from.endpointId).withFingerprint(i.from.fingerprint).aboutSessionEnded(r.fingerprint)
            }
            )
        }
        ),
        t.onDisconnect.addListener( () => {
            var o, i;
            ((o = x.get(r.endpointName)) == null ? void 0 : o.fingerprint) === r.fingerprint && x.delete(r.endpointName),
            (i = V.get(r.fingerprint)) == null || i.forEach(a => a()),
            V.delete(r.fingerprint)
        }
        ),
        t.onMessage.addListener(o => {
            var i, a;
            if (o.type === "sync") {
                const c = [...x.values()].map(h => h.fingerprint)
                  , u = o.pendingResponses.filter(h => c.includes(h.to));
                j.add(...u),
                o.pendingResponses.filter(h => !c.includes(h.to)).forEach(h => C(r.endpointName).withFingerprint(r.fingerprint).aboutSessionEnded(h.to)),
                o.pendingDeliveries.forEach(h => C(r.endpointName).withFingerprint(r.fingerprint).whenDeliverableTo(h));
                return
            }
            o.type === "deliver" && ((a = (i = o.message) == null ? void 0 : i.origin) != null && a.context) && (o.message.origin.tabId = s,
            o.message.origin.frameId = n,
            X.handleMessage(o.message))
        }
        )
    }
    );
    var {sendMessage: gt, onMessage: ae} = X;
    ot(X);
    class ce extends Error {
        response;
        request;
        options;
        constructor(e, r, s) {
            const n = e.status || e.status === 0 ? e.status : ""
              , o = e.statusText ?? ""
              , i = `${n} ${o}`.trim()
              , a = i ? `status code ${i}` : "an unknown error";
            super(`Request failed with ${a}: ${r.method} ${r.url}`),
            this.name = "HTTPError",
            this.response = e,
            this.request = r,
            this.options = s
        }
    }
    class ke extends Error {
        name = "NonError";
        value;
        constructor(e) {
            let r = "Non-error value was thrown";
            try {
                typeof e == "string" ? r = e : e && typeof e == "object" && "message"in e && typeof e.message == "string" && (r = e.message)
            } catch {}
            super(r),
            this.value = e
        }
    }
    class le extends Error {
        name = "ForceRetryError";
        customDelay;
        code;
        customRequest;
        constructor(e) {
            const r = e?.cause ? e.cause instanceof Error ? e.cause : new ke(e.cause) : void 0;
            super(e?.code ? `Forced retry: ${e.code}` : "Forced retry", r ? {
                cause: r
            } : void 0),
            this.customDelay = e?.delay,
            this.code = e?.code,
            this.customRequest = e?.request
        }
    }
    const Re = ( () => {
        let t = !1
          , e = !1;
        const r = typeof globalThis.ReadableStream == "function"
          , s = typeof globalThis.Request == "function";
        if (r && s)
            try {
                e = new globalThis.Request("https://empty.invalid",{
                    body: new globalThis.ReadableStream,
                    method: "POST",
                    get duplex() {
                        return t = !0,
                        "half"
                    }
                }).headers.has("Content-Type")
            } catch (n) {
                if (n instanceof Error && n.message === "unsupported BodyInit type")
                    return !1;
                throw n
            }
        return t && !e
    }
    )()
      , dt = typeof globalThis.AbortController == "function"
      , _e = typeof globalThis.AbortSignal == "function" && typeof globalThis.AbortSignal.any == "function"
      , ft = typeof globalThis.ReadableStream == "function"
      , mt = typeof globalThis.FormData == "function"
      , Ie = ["get", "post", "put", "patch", "head", "delete"]
      , ht = {
        json: "application/json",
        text: "text/*",
        formData: "multipart/form-data",
        arrayBuffer: "*/*",
        blob: "*/*",
        bytes: "*/*"
    }
      , ue = 2147483647
      , pt = new TextEncoder().encode("------WebKitFormBoundaryaxpyiPgbbPti10Rw").length
      , Pe = Symbol("stop");
    class Ce {
        options;
        constructor(e) {
            this.options = e
        }
    }
    const At = t => new Ce(t)
      , yt = {
        json: !0,
        parseJson: !0,
        stringifyJson: !0,
        searchParams: !0,
        prefixUrl: !0,
        retry: !0,
        timeout: !0,
        hooks: !0,
        throwHttpErrors: !0,
        onDownloadProgress: !0,
        onUploadProgress: !0,
        fetch: !0,
        context: !0
    }
      , bt = {
        next: !0
    }
      , wt = {
        method: !0,
        headers: !0,
        body: !0,
        mode: !0,
        credentials: !0,
        cache: !0,
        redirect: !0,
        referrer: !0,
        referrerPolicy: !0,
        integrity: !0,
        keepalive: !0,
        signal: !0,
        window: !0,
        duplex: !0
    }
      , xt = t => {
        if (!t)
            return 0;
        if (t instanceof FormData) {
            let e = 0;
            for (const [r,s] of t)
                e += pt,
                e += new TextEncoder().encode(`Content-Disposition: form-data; name="${r}"`).length,
                e += typeof s == "string" ? new TextEncoder().encode(s).length : s.size;
            return e
        }
        if (t instanceof Blob)
            return t.size;
        if (t instanceof ArrayBuffer)
            return t.byteLength;
        if (typeof t == "string")
            return new TextEncoder().encode(t).length;
        if (t instanceof URLSearchParams)
            return new TextEncoder().encode(t.toString()).length;
        if ("byteLength"in t)
            return t.byteLength;
        if (typeof t == "object" && t !== null)
            try {
                const e = JSON.stringify(t);
                return new TextEncoder().encode(e).length
            } catch {
                return 0
            }
        return 0
    }
      , Me = (t, e, r) => {
        let s, n = 0;
        return t.pipeThrough(new TransformStream({
            transform(o, i) {
                if (i.enqueue(o),
                s) {
                    n += s.byteLength;
                    let a = e === 0 ? 0 : n / e;
                    a >= 1 && (a = 1 - Number.EPSILON),
                    r?.({
                        percent: a,
                        totalBytes: Math.max(e, n),
                        transferredBytes: n
                    }, s)
                }
                s = o
            },
            flush() {
                s && (n += s.byteLength,
                r?.({
                    percent: 1,
                    totalBytes: Math.max(e, n),
                    transferredBytes: n
                }, s))
            }
        }))
    }
      , Tt = (t, e) => {
        if (!t.body)
            return t;
        if (t.status === 204)
            return new Response(null,{
                status: t.status,
                statusText: t.statusText,
                headers: t.headers
            });
        const r = Math.max(0, Number(t.headers.get("content-length")) || 0);
        return new Response(Me(t.body, r, e),{
            status: t.status,
            statusText: t.statusText,
            headers: t.headers
        })
    }
      , vt = (t, e, r) => {
        if (!t.body)
            return t;
        const s = xt(r ?? t.body);
        return new Request(t,{
            duplex: "half",
            body: Me(t.body, s, e)
        })
    }
      , M = t => t !== null && typeof t == "object"
      , Z = (...t) => {
        for (const e of t)
            if ((!M(e) || Array.isArray(e)) && e !== void 0)
                throw new TypeError("The `options` argument must be an object");
        return ge({}, ...t)
    }
      , Ne = (t={}, e={}) => {
        const r = new globalThis.Headers(t)
          , s = e instanceof globalThis.Headers
          , n = new globalThis.Headers(e);
        for (const [o,i] of n.entries())
            s && i === "undefined" || i === void 0 ? r.delete(o) : r.set(o, i);
        return r
    }
    ;
    function Y(t, e, r) {
        return Object.hasOwn(e, r) && e[r] === void 0 ? [] : ge(t[r] ?? [], e[r] ?? [])
    }
    const Oe = (t={}, e={}) => ({
        beforeRequest: Y(t, e, "beforeRequest"),
        beforeRetry: Y(t, e, "beforeRetry"),
        afterResponse: Y(t, e, "afterResponse"),
        beforeError: Y(t, e, "beforeError")
    })
      , Et = (t, e) => {
        const r = new URLSearchParams;
        for (const s of [t, e])
            if (s !== void 0)
                if (s instanceof URLSearchParams)
                    for (const [n,o] of s.entries())
                        r.append(n, o);
                else if (Array.isArray(s))
                    for (const n of s) {
                        if (!Array.isArray(n) || n.length !== 2)
                            throw new TypeError("Array search parameters must be provided in [[key, value], ...] format");
                        r.append(String(n[0]), String(n[1]))
                    }
                else if (M(s))
                    for (const [n,o] of Object.entries(s))
                        o !== void 0 && r.append(n, String(o));
                else {
                    const n = new URLSearchParams(s);
                    for (const [o,i] of n.entries())
                        r.append(o, i)
                }
        return r
    }
      , ge = (...t) => {
        let e = {}, r = {}, s = {}, n;
        const o = [];
        for (const i of t)
            if (Array.isArray(i))
                Array.isArray(e) || (e = []),
                e = [...e, ...i];
            else if (M(i)) {
                for (let[a,c] of Object.entries(i)) {
                    if (a === "signal" && c instanceof globalThis.AbortSignal) {
                        o.push(c);
                        continue
                    }
                    if (a === "context") {
                        if (c != null && (!M(c) || Array.isArray(c)))
                            throw new TypeError("The `context` option must be an object");
                        e = {
                            ...e,
                            context: c == null ? {} : {
                                ...e.context,
                                ...c
                            }
                        };
                        continue
                    }
                    if (a === "searchParams") {
                        c == null ? n = void 0 : n = n === void 0 ? c : Et(n, c);
                        continue
                    }
                    M(c) && a in e && (c = ge(e[a], c)),
                    e = {
                        ...e,
                        [a]: c
                    }
                }
                M(i.hooks) && (s = Oe(s, i.hooks),
                e.hooks = s),
                M(i.headers) && (r = Ne(r, i.headers),
                e.headers = r)
            }
        return n !== void 0 && (e.searchParams = n),
        o.length > 0 && (o.length === 1 ? e.signal = o[0] : _e ? e.signal = AbortSignal.any(o) : e.signal = o.at(-1)),
        e.context === void 0 && (e.context = {}),
        e
    }
      , St = t => Ie.includes(t) ? t.toUpperCase() : t
      , De = {
        limit: 2,
        methods: ["get", "put", "head", "delete", "options", "trace"],
        statusCodes: [408, 413, 429, 500, 502, 503, 504],
        afterStatusCodes: [413, 429, 503],
        maxRetryAfter: Number.POSITIVE_INFINITY,
        backoffLimit: Number.POSITIVE_INFINITY,
        delay: t => .3 * 2 ** (t - 1) * 1e3,
        jitter: void 0,
        retryOnTimeout: !1
    }
      , kt = (t={}) => {
        if (typeof t == "number")
            return {
                ...De,
                limit: t
            };
        if (t.methods && !Array.isArray(t.methods))
            throw new Error("retry.methods must be an array");
        if (t.statusCodes && !Array.isArray(t.statusCodes))
            throw new Error("retry.statusCodes must be an array");
        return {
            ...De,
            ...t
        }
    }
    ;
    class de extends Error {
        request;
        constructor(e) {
            super(`Request timed out: ${e.method} ${e.url}`),
            this.name = "TimeoutError",
            this.request = e
        }
    }
    async function Rt(t, e, r, s) {
        return new Promise( (n, o) => {
            const i = setTimeout( () => {
                r && r.abort(),
                o(new de(t))
            }
            , s.timeout);
            s.fetch(t, e).then(n).catch(o).then( () => {
                clearTimeout(i)
            }
            )
        }
        )
    }
    async function _t(t, {signal: e}) {
        return new Promise( (r, s) => {
            e && (e.throwIfAborted(),
            e.addEventListener("abort", n, {
                once: !0
            }));
            function n() {
                clearTimeout(o),
                s(e.reason)
            }
            const o = setTimeout( () => {
                e?.removeEventListener("abort", n),
                r()
            }
            , t)
        }
        )
    }
    const It = (t, e) => {
        const r = {};
        for (const s in e)
            Object.hasOwn(e, s) && !(s in wt) && !(s in yt) && (!(s in t) || s in bt) && (r[s] = e[s]);
        return r
    }
      , Pt = t => t === void 0 ? !1 : Array.isArray(t) ? t.length > 0 : t instanceof URLSearchParams ? t.size > 0 : typeof t == "object" ? Object.keys(t).length > 0 : typeof t == "string" ? t.trim().length > 0 : !!t;
    function Ct(t) {
        return t instanceof ce || t?.name === ce.name
    }
    function Mt(t) {
        return t instanceof de || t?.name === de.name
    }
    class L {
        static create(e, r) {
            const s = new L(e,r)
              , n = async () => {
                if (typeof s.#e.timeout == "number" && s.#e.timeout > ue)
                    throw new RangeError(`The \`timeout\` option cannot be greater than ${ue}`);
                await Promise.resolve();
                let i = await s.#h();
                for (const a of s.#e.hooks.afterResponse) {
                    const c = s.#u(i.clone())
                      , u = await a(s.request, s.#a(), c, {
                        retryCount: s.#r
                    });
                    if (u instanceof globalThis.Response && (i = u),
                    u instanceof Ce)
                        throw await Promise.all([c.body?.cancel(), i.body?.cancel()]),
                        new le(u.options)
                }
                if (s.#u(i),
                !i.ok && (typeof s.#e.throwHttpErrors == "function" ? s.#e.throwHttpErrors(i.status) : s.#e.throwHttpErrors)) {
                    let a = new ce(i,s.request,s.#a());
                    for (const c of s.#e.hooks.beforeError)
                        a = await c(a, {
                            retryCount: s.#r
                        });
                    throw a
                }
                if (s.#e.onDownloadProgress) {
                    if (typeof s.#e.onDownloadProgress != "function")
                        throw new TypeError("The `onDownloadProgress` option must be a function");
                    if (!ft)
                        throw new Error("Streams are not supported in your environment. `ReadableStream` is missing.");
                    return Tt(i.clone(), s.#e.onDownloadProgress)
                }
                return i
            }
              , o = s.#g(n).finally(async () => {
                const i = s.#o
                  , a = [];
                i && !i.bodyUsed && a.push(i.body?.cancel()),
                s.request.bodyUsed || a.push(s.request.body?.cancel()),
                await Promise.all(a)
            }
            );
            for (const [i,a] of Object.entries(ht))
                i === "bytes" && typeof globalThis.Response?.prototype?.bytes != "function" || (o[i] = async () => {
                    s.request.headers.set("accept", s.request.headers.get("accept") || a);
                    const c = await o;
                    if (i === "json") {
                        if (c.status === 204)
                            return "";
                        const u = await c.text();
                        return u === "" ? "" : r.parseJson ? r.parseJson(u) : JSON.parse(u)
                    }
                    return c[i]()
                }
                );
            return o
        }
        static #f(e) {
            return e && typeof e == "object" && !Array.isArray(e) && !(e instanceof URLSearchParams) ? Object.fromEntries(Object.entries(e).filter( ([,r]) => r !== void 0)) : e
        }
        request;
        #s;
        #r = 0;
        #t;
        #e;
        #o;
        #n;
        #i;
        constructor(e, r={}) {
            if (this.#t = e,
            this.#e = {
                ...r,
                headers: Ne(this.#t.headers, r.headers),
                hooks: Oe({
                    beforeRequest: [],
                    beforeRetry: [],
                    beforeError: [],
                    afterResponse: []
                }, r.hooks),
                method: St(r.method ?? this.#t.method ?? "GET"),
                prefixUrl: String(r.prefixUrl || ""),
                retry: kt(r.retry),
                throwHttpErrors: r.throwHttpErrors ?? !0,
                timeout: r.timeout ?? 1e4,
                fetch: r.fetch ?? globalThis.fetch.bind(globalThis),
                context: r.context ?? {}
            },
            typeof this.#t != "string" && !(this.#t instanceof URL || this.#t instanceof globalThis.Request))
                throw new TypeError("`input` must be a string, URL, or Request");
            if (this.#e.prefixUrl && typeof this.#t == "string") {
                if (this.#t.startsWith("/"))
                    throw new Error("`input` must not begin with a slash when using `prefixUrl`");
                this.#e.prefixUrl.endsWith("/") || (this.#e.prefixUrl += "/"),
                this.#t = this.#e.prefixUrl + this.#t
            }
            dt && _e && (this.#n = this.#e.signal ?? this.#t.signal,
            this.#s = new globalThis.AbortController,
            this.#e.signal = this.#n ? AbortSignal.any([this.#n, this.#s.signal]) : this.#s.signal),
            Re && (this.#e.duplex = "half"),
            this.#e.json !== void 0 && (this.#e.body = this.#e.stringifyJson?.(this.#e.json) ?? JSON.stringify(this.#e.json),
            this.#e.headers.set("content-type", this.#e.headers.get("content-type") ?? "application/json"));
            const s = r.headers && new globalThis.Headers(r.headers).has("content-type");
            if (this.#t instanceof globalThis.Request && (mt && this.#e.body instanceof globalThis.FormData || this.#e.body instanceof URLSearchParams) && !s && this.#e.headers.delete("content-type"),
            this.request = new globalThis.Request(this.#t,this.#e),
            Pt(this.#e.searchParams)) {
                const o = "?" + (typeof this.#e.searchParams == "string" ? this.#e.searchParams.replace(/^\?/, "") : new URLSearchParams(L.#f(this.#e.searchParams)).toString())
                  , i = this.request.url.replace(/(?:\?.*?)?(?=#|$)/, o);
                this.request = new globalThis.Request(i,this.#e)
            }
            if (this.#e.onUploadProgress) {
                if (typeof this.#e.onUploadProgress != "function")
                    throw new TypeError("The `onUploadProgress` option must be a function");
                if (!Re)
                    throw new Error("Request streams are not supported in your environment. The `duplex` option for `Request` is not available.");
                this.request = this.#d(this.request, this.#e.body ?? void 0)
            }
        }
        #c() {
            const e = this.#e.retry.delay(this.#r);
            let r = e;
            return this.#e.retry.jitter === !0 ? r = Math.random() * e : typeof this.#e.retry.jitter == "function" && (r = this.#e.retry.jitter(e),
            (!Number.isFinite(r) || r < 0) && (r = e)),
            Math.min(this.#e.retry.backoffLimit, r)
        }
        async #m(e) {
            if (this.#r++,
            this.#r > this.#e.retry.limit)
                throw e;
            const r = e instanceof Error ? e : new ke(e);
            if (r instanceof le)
                return r.customDelay ?? this.#c();
            if (!this.#e.retry.methods.includes(this.request.method.toLowerCase()))
                throw e;
            if (this.#e.retry.shouldRetry !== void 0) {
                const s = await this.#e.retry.shouldRetry({
                    error: r,
                    retryCount: this.#r
                });
                if (s === !1)
                    throw e;
                if (s === !0)
                    return this.#c()
            }
            if (Mt(e) && !this.#e.retry.retryOnTimeout)
                throw e;
            if (Ct(e)) {
                if (!this.#e.retry.statusCodes.includes(e.response.status))
                    throw e;
                const s = e.response.headers.get("Retry-After") ?? e.response.headers.get("RateLimit-Reset") ?? e.response.headers.get("X-RateLimit-Retry-After") ?? e.response.headers.get("X-RateLimit-Reset") ?? e.response.headers.get("X-Rate-Limit-Reset");
                if (s && this.#e.retry.afterStatusCodes.includes(e.response.status)) {
                    let n = Number(s) * 1e3;
                    Number.isNaN(n) ? n = Date.parse(s) - Date.now() : n >= Date.parse("2024-01-01") && (n -= Date.now());
                    const o = this.#e.retry.maxRetryAfter ?? n;
                    return n < o ? n : o
                }
                if (e.response.status === 413)
                    throw e
            }
            return this.#c()
        }
        #u(e) {
            return this.#e.parseJson && (e.json = async () => this.#e.parseJson(await e.text())),
            e
        }
        async #g(e) {
            try {
                return await e()
            } catch (r) {
                const s = Math.min(await this.#m(r), ue);
                if (this.#r < 1)
                    throw r;
                if (await _t(s, this.#n ? {
                    signal: this.#n
                } : {}),
                r instanceof le && r.customRequest) {
                    const n = this.#e.signal ? new globalThis.Request(r.customRequest,{
                        signal: this.#e.signal
                    }) : new globalThis.Request(r.customRequest);
                    this.#l(n)
                }
                for (const n of this.#e.hooks.beforeRetry) {
                    const o = await n({
                        request: this.request,
                        options: this.#a(),
                        error: r,
                        retryCount: this.#r
                    });
                    if (o instanceof globalThis.Request) {
                        this.#l(o);
                        break
                    }
                    if (o instanceof globalThis.Response)
                        return o;
                    if (o === Pe)
                        return
                }
                return this.#g(e)
            }
        }
        async #h() {
            this.#s?.signal.aborted && (this.#s = new globalThis.AbortController,
            this.#e.signal = this.#n ? AbortSignal.any([this.#n, this.#s.signal]) : this.#s.signal,
            this.request = new globalThis.Request(this.request,{
                signal: this.#e.signal
            }));
            for (const r of this.#e.hooks.beforeRequest) {
                const s = await r(this.request, this.#a(), {
                    retryCount: this.#r
                });
                if (s instanceof Response)
                    return s;
                if (s instanceof globalThis.Request) {
                    this.#l(s);
                    break
                }
            }
            const e = It(this.request, this.#e);
            return this.#o = this.request,
            this.request = this.#o.clone(),
            this.#e.timeout === !1 ? this.#e.fetch(this.#o, e) : Rt(this.#o, e, this.#s, this.#e)
        }
        #a() {
            if (!this.#i) {
                const {hooks: e, ...r} = this.#e;
                this.#i = Object.freeze(r)
            }
            return this.#i
        }
        #l(e) {
            this.#i = void 0,
            this.request = this.#d(e)
        }
        #d(e, r) {
            return !this.#e.onUploadProgress || !e.body ? e : vt(e, this.#e.onUploadProgress, r ?? this.#e.body ?? void 0)
        }
    }
    const fe = t => {
        const e = (r, s) => L.create(r, Z(t, s));
        for (const r of Ie)
            e[r] = (s, n) => L.create(s, Z(t, n, {
                method: r
            }));
        return e.create = r => fe(Z(r)),
        e.extend = r => (typeof r == "function" && (r = r(t ?? {})),
        fe(Z(t, r))),
        e.stop = Pe,
        e.retry = At,
        e
    }
      , K = fe();
    class Nt {
        static async post(e, r, s={}) {
            try {
                return await (await K.post(e, {
                    json: r,
                    timeout: 1e4,
                    retry: 2,
                    ...s
                })).json()
            } catch (n) {
                throw console.error("HttpBridge post request failed:", n),
                n
            }
        }
        static async get(e, r={}) {
            try {
                return await (await K.get(e, {
                    timeout: 1e4,
                    retry: 2,
                    ...r
                })).json()
            } catch (s) {
                throw console.error("HttpBridge get request failed:", s),
                s
            }
        }
        static async postNoReturn(e, r, s={}) {
            try {
                await K.post(e, {
                    json: r,
                    timeout: 1e4,
                    retry: 2,
                    ...s
                })
            } catch (n) {
                throw console.error("HttpBridge postNoReturn request failed:", n),
                n
            }
        }
    }
    const Ot = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
    let Dt = (t=21) => {
        let e = ""
          , r = crypto.getRandomValues(new Uint8Array(t |= 0));
        for (; t--; )
            e += Ot[r[t] & 63];
        return e
    }
    ;
    const qt = void 0
      , U = {
        ENDPOINT: "https://www.google-analytics.com/mp/collect",
        MEASUREMENT_ID: "G-BE0V18QLRS",
        API_SECRET: "f8hhcpz6Tuu1uUxHRNDaHA",
        SESSION_EXPIRATION_IN_MIN: 30,
        DEFAULT_ENGAGEMENT_TIME_IN_MSEC: 100
    };
    ae("ga4-send-event", ({data: t}) => {
        try {
            const {eventName: e, params: r} = t;
            Q(e, r)
        } catch {}
    }
    );
    async function qe() {
        try {
            let e = (await p.storage.local.get("clientId")).clientId;
            return e || (e = Dt(32),
            await p.storage.local.set({
                clientId: e
            })),
            e
        } catch (t) {
            return console.error("Error getting/creating client ID:", t),
            Math.random().toString(36).substring(2, 15)
        }
    }
    async function je() {
        try {
            let {sessionData: t} = await p.storage.session.get("sessionData");
            const e = Date.now();
            return t && t.timestamp && ((e - t.timestamp) / 6e4 > U.SESSION_EXPIRATION_IN_MIN ? t = void 0 : (t.timestamp = e,
            await p.storage.session.set({
                sessionData: t
            }))),
            t || (t = {
                sessionId: e.toString(),
                timestamp: e
            },
            await p.storage.session.set({
                sessionData: t
            })),
            t.sessionId
        } catch (t) {
            return console.error("Error getting/creating session ID:", t),
            Date.now().toString()
        }
    }
    async function jt() {}
    async function Lt(t, e={}) {
        try {
            const r = await qe()
              , s = await je()
              , n = {
                ...e,
                session_id: s,
                engagement_time_msec: U.DEFAULT_ENGAGEMENT_TIME_IN_MSEC,
                ext_version: qt,
                browser_type: "chrome"
            }
              , o = {
                client_id: r,
                events: [{
                    name: t,
                    params: n
                }]
            }
              , i = `${U.ENDPOINT}?measurement_id=${U.MEASUREMENT_ID}&api_secret=${U.API_SECRET}`;
            await Nt.postNoReturn(i, o)
        } catch (r) {
            console.error("Error sending GA4 event:", r)
        }
    }
    async function Q(t, e={}) {
        try {
            Lt(t, e)
        } catch (r) {
            console.error("Error in sendEvent:", r)
        }
    }
    async function Ut() {
        try {
            const t = await qe()
              , e = await je();
            await Q("first_visit", {
                version: p.runtime.getManifest().version,
                client_id: t,
                ga_session_id: e,
                ga_session_number: 1,
                page_title: "install",
                page_location: "location"
            }),
            await Q("first_open", {
                version: p.runtime.getManifest().version,
                client_id: t,
                ga_session_id: e,
                page_title: "install",
                page_location: "location"
            }),
            setTimeout( () => {
                Q("extension_installed", {
                    version: p.runtime.getManifest().version,
                    client_id: t,
                    ga_session_id: e,
                    page_title: "install",
                    page_location: "location"
                })
            }
            , 200)
        } catch (t) {
            console.error("Error in firstVisit:", t)
        }
    }
    const $t = "https://www.saveai.net"
      , ee = {};
    let Le = !1;
    const Ft = t => !!t && (typeof t == "object" || typeof t == "function") && typeof t.then == "function"
      , Bt = () => {
        p.runtime.onMessage.addListener( (t, e, r) => {
            if (!t)
                return;
            const s = t
              , n = ee[s.eventName];
            let o;
            if (n)
                return n.map(i => {
                    const a = i(s.data, e)
                      , c = {
                        resStatus: 0,
                        data: a,
                        message: "success"
                    };
                    Ft(a) ? (a.then(u => {
                        c.data = u,
                        r(c)
                    }
                    ).catch(u => {
                        u.name === "HTTPError" ? r(u) : r({
                            resStatus: -1,
                            message: u.message
                        })
                    }
                    ),
                    o = !0) : r(c)
                }
                ),
                o
        }
        )
    }
    ;
    class te {
        static sendMessageToDefault(e) {
            return new Promise( (r, s) => {
                p.runtime.sendMessage(e).then(n => {
                    n === null && r(void 0),
                    n && n.resStatus === 0 ? r(n.data) : s(n)
                }
                ).catch(n => {
                    s(n)
                }
                )
            }
            )
        }
        static sendMessageToContent(e, r) {
            return new Promise( (s, n) => {
                p.tabs.sendMessage(r, e).then(o => {
                    o === null && s(void 0),
                    o && o.resStatus === 0 ? s(o.data) : n(o)
                }
                ).catch(o => {
                    n(o)
                }
                )
            }
            )
        }
        static sendMessage(e, r, s) {
            const n = {
                eventName: e,
                data: r
            };
            return typeof s == "number" ? this.sendMessageToContent(n, s) : this.sendMessageToDefault(n)
        }
        static sendMessageToActiveTab(e, r) {
            return new Promise( (s, n) => {
                p.tabs.query({
                    active: !0,
                    currentWindow: !0
                }).then(o => {
                    const i = {
                        eventName: e,
                        data: r
                    };
                    if (o[0]) {
                        const a = o[0].id;
                        a != null ? this.sendMessageToContent(i, a).then(s).catch(n) : n(new Error("No active tab found."))
                    } else
                        n(new Error("No active tabs found."))
                }
                ).catch(o => {
                    n(o)
                }
                )
            }
            )
        }
        static onMessage(e, r) {
            ee[e] || (ee[e] = []),
            ee[e].push(r),
            Le || (Le = !0,
            Bt())
        }
    }
    const Ue = () => {
        if (p?.extension?.getBackgroundPage && p?.extension?.getBackgroundPage() === window)
            return !0;
        try {
            return typeof self < "u" && self.ServiceWorkerGlobalScope
        } catch {
            return !1
        }
    }
    ;
    let $e = !1;
    class Ht {
        static async fetch(e, r, s="json", n=!1, o=0) {
            if (!Ue())
                return;
            const a = {
                ...r,
                headers: n ? {} : {
                    ...{},
                    ...r?.headers
                }
            };
            let c = 1e3 * 30;
            return e.toString().includes("/api/v1/make/pdf") && (c = 6e4),
            K(e, {
                retry: 2,
                timeout: c,
                ...a
            }).then(async u => s === "json" ? u.json() : s === "text" ? u.text() : s === "blob" ? u.blob() : s === "arrayBuffer" ? u.arrayBuffer() : s === "formData" ? u.formData() : s === "no-resolve" ? u : Promise.resolve({})).catch(async u => {
                if (u.name === "HTTPError") {
                    const h = await u.response.json();
                    throw {
                        name: u?.name,
                        code: u.response?.code,
                        status: u.response?.status,
                        message: h.message,
                        ...h
                    }
                } else if (u.name === "TimeoutError") {
                    if (o === 0)
                        return this.fetch(e, r, s, n, o + 1);
                    throw {
                        name: "HTTPError",
                        code: 408,
                        status: 408,
                        message: u.message
                    }
                } else
                    throw {
                        name: "HTTPError",
                        code: -1,
                        status: 500,
                        message: u.message
                    }
            }
            )
        }
        static setMessageListener() {
            $e || !Ue() || ($e = !0,
            te.onMessage("to-fetch-data", async e => this.fetch(e.input, e.init, e.resolve, !!e.noAuth)))
        }
    }
    class Wt {
        static async getCookie(e, r) {
            return await p.cookies.get({
                url: r,
                name: e
            })
        }
        static async setCookie({key: e, value: r, domain: s, url: n, expiresDays: o}) {
            return await p.cookies.set({
                url: n,
                domain: s,
                name: e,
                value: r,
                expirationDate: Math.floor(Date.now() / 1e3) + o * 24 * 60 * 60
            })
        }
        static async getAllCookies(e) {
            try {
                console.log("getAllCookies");
                const r = await p.cookies.getAll({
                    url: e
                });
                return console.log("resLddd", r),
                r
            } catch (r) {
                console.error(r)
            }
        }
        static setMessageListener() {
            te.onMessage("get-cookie-data", async e => await this.getCookie(e.key, e.domain)),
            te.onMessage("set-cookie-data", async e => await this.setCookie(e)),
            te.onMessage("get-all-cookies", async e => (console.log("get-all-cookies:", e.domain),
            await this.getAllCookies(e.domain)))
        }
    }
    const zt = Be({
        persistent: void 0,
        type: void 0,
        include: void 0,
        exclude: void 0,
        main() {
            Ht.setMessageListener(),
            Wt.setMessageListener(),
            jt(),
            p.runtime.onInstalled.addListener(e => {
                e.reason === "install" ? (p.tabs.create({
                    active: !0,
                    url: $t
                }),
                Ut()) : e.reason
            }
            );
            let t = 0;
            p.tabs.onActivated.addListener(async ({tabId: e}) => {
                if (!t) {
                    t = e;
                    return
                }
                let r;
                try {
                    r = await p.tabs.get(t),
                    t = e
                } catch {
                    return
                }
                gt("tab-prev", {
                    context: "content-script",
                    tabId: e
                })
            }
            ),
            ae("get-current-tab", async () => {
                try {
                    const e = await p.tabs.get(t);
                    return {
                        title: e?.title,
                        tabId: e?.id
                    }
                } catch {
                    return {
                        title: void 0,
                        tabId: void 0
                    }
                }
            }
            ),
            ae("get-active-tab", async () => {
                try {
                    const e = await p.tabs.query({
                        active: !0,
                        currentWindow: !0
                    });
                    return e[0]?.id ? {
                        tabId: e[0].id,
                        title: e[0].title,
                        url: e[0].url
                    } : {
                        tabId: void 0,
                        error: "tab"
                    }
                } catch (e) {
                    return console.error("tab:", e),
                    {
                        tabId: void 0,
                        error: e?.message || "tab"
                    }
                }
            }
            )
        }
    });
    function Qt() {}
    function re(t, ...e) {}
    const Jt = {
        debug: (...t) => re(console.debug, ...t),
        log: (...t) => re(console.log, ...t),
        warn: (...t) => re(console.warn, ...t),
        error: (...t) => re(console.error, ...t)
    };
    let me;
    try {
        me = zt.main(),
        me instanceof Promise && console.warn("The background's main() function return a promise, but it must be synchronous")
    } catch (t) {
        throw Jt.error("The background crashed on startup!"),
        t
    }
    return me
}
)();
