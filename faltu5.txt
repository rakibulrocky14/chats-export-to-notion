var injectWeb = (function() {
    "use strict";
    function l(a) {
        return a == null || typeof a == "function" ? {
            main: a
        } : a
    }
    const u = "web-bridge"
      , h = "__handshake__";
    class c {
        constructor(e, t={}) {
            this.messageHandlers = new Map,
            this.pendingRequests = new Map,
            this.isReady = !1,
            this.handshakeAttempts = 0,
            this.options = {
                requestTimeout: 3e4,
                handshakeTimeout: 500,
                handshakeRetryInterval: 1e3,
                maxHandshakeAttempts: 10
            },
            this.handleMessage = n => {
                const s = n.data;
                !s || typeof s != "object" || s.type !== this.messageType || this.isAllowedId(s.communicationId) && (s.action && this.handleRequestMessage(s),
                s.requestId && this.handleResponseMessage(s))
            }
            ,
            this.communicationId = e,
            this.messageType = t.messageType || u,
            this.allowedIds = new Set(t.allowedIds || []),
            Object.assign(this.options, t),
            this.setupMessageListener(),
            this.setupHandshakeHandler()
        }
        addAllowedId(e) {
            this.allowedIds.add(e)
        }
        removeAllowedId(e) {
            this.allowedIds.delete(e)
        }
        isAllowedId(e) {
            return this.allowedIds.size === 0 || this.allowedIds.has(e)
        }
        generateId() {
            return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`
        }
        async ensureReady() {
            if (!this.isReady) {
                if (this.readyPromise)
                    return this.readyPromise;
                this.readyPromise = this.performHandshakeWithRetry();
                try {
                    await this.readyPromise
                } finally {
                    this.readyPromise = void 0
                }
            }
        }
        async performHandshakeWithRetry() {
            return new Promise( (e, t) => {
                const n = async () => {
                    try {
                        await this.sendSingleHandshakeRequest(),
                        this.isReady = !0,
                        this.stopHandshakeRetry(),
                        e()
                    } catch (s) {
                        if (this.handshakeAttempts++,
                        this.handshakeAttempts >= this.options.maxHandshakeAttempts) {
                            this.stopHandshakeRetry(),
                            t(new Error(`建联失败: ${s}`));
                            return
                        }
                        this.handshakeRetryInterval = setTimeout(n, this.options.handshakeRetryInterval)
                    }
                }
                ;
                n()
            }
            )
        }
        async sendSingleHandshakeRequest() {
            return new Promise( (e, t) => {
                const n = this.generateId()
                  , s = setTimeout( () => {
                    this.pendingRequests.delete(n),
                    t(new Error("握手超时"))
                }
                , this.options.handshakeTimeout);
                this.pendingRequests.set(n, {
                    resolve: e,
                    reject: t,
                    timeout: s
                });
                const i = {
                    type: this.messageType,
                    communicationId: this.communicationId,
                    id: n,
                    action: h,
                    data: {
                        timestamp: Date.now()
                    },
                    needResponse: !0,
                    timestamp: Date.now()
                };
                globalThis.postMessage(i, "*")
            }
            )
        }
        stopHandshakeRetry() {
            this.handshakeRetryInterval && (clearTimeout(this.handshakeRetryInterval),
            this.handshakeRetryInterval = void 0)
        }
        send(e, t) {
            const n = {
                type: this.messageType,
                communicationId: this.communicationId,
                id: this.generateId(),
                action: e,
                data: t,
                needResponse: !1,
                timestamp: Date.now()
            };
            globalThis.postMessage(n, "*")
        }
        async invoke(e, t) {
            return await this.ensureReady(),
            this.invokeRequest(e, t)
        }
        async invokeRequest(e, t) {
            return new Promise( (n, s) => {
                const i = this.generateId()
                  , r = setTimeout( () => {
                    this.pendingRequests.delete(i),
                    s(new Error(`请求超时: ${e}`))
                }
                , this.options.requestTimeout);
                this.pendingRequests.set(i, {
                    resolve: n,
                    reject: s,
                    timeout: r
                });
                const o = {
                    type: this.messageType,
                    communicationId: this.communicationId,
                    id: i,
                    action: e,
                    data: t,
                    needResponse: !0,
                    timestamp: Date.now()
                };
                globalThis.postMessage(o, "*")
            }
            )
        }
        handle(e, t) {
            return this.messageHandlers.set(e, t),
            () => {
                this.messageHandlers.delete(e)
            }
        }
        getReady() {
            return this.isReady
        }
        destroy() {
            this.stopHandshakeRetry(),
            this.messageHandlers.clear(),
            this.clearPendingRequests(),
            globalThis.removeEventListener("message", this.handleMessage)
        }
        setupMessageListener() {
            this.handleMessage = this.handleMessage.bind(this),
            globalThis.addEventListener("message", this.handleMessage)
        }
        async handleRequestMessage(e) {
            const {action: t, data: n, needResponse: s, id: i} = e;
            try {
                const r = this.messageHandlers.get(t);
                if (!r) {
                    s && this.sendResponse(i, !1, void 0, `未找到处理器: ${t}`);
                    return
                }
                let o = r(n);
                o && typeof o.then == "function" && (o = await o),
                s && this.sendResponse(i, !0, o)
            } catch (r) {
                if (console.error(`处理消息错误 [${t}]:`, r),
                s) {
                    const o = r instanceof Error ? r.message : String(r);
                    this.sendResponse(i, !1, void 0, o)
                }
            }
        }
        handleResponseMessage(e) {
            const {requestId: t, success: n, data: s, error: i} = e
              , r = this.pendingRequests.get(t);
            r && (clearTimeout(r.timeout),
            this.pendingRequests.delete(t),
            n ? r.resolve(s) : r.reject(new Error(i || "未知错误")))
        }
        sendResponse(e, t, n, s) {
            const i = {
                type: this.messageType,
                communicationId: this.communicationId,
                id: this.generateId(),
                requestId: e,
                success: t,
                data: n,
                error: s,
                timestamp: Date.now()
            };
            globalThis.postMessage(i, "*")
        }
        setupHandshakeHandler() {
            this.handle(h, e => ({
                success: !0,
                timestamp: Date.now()
            }))
        }
        clearPendingRequests() {
            this.pendingRequests.forEach( ({reject: e, timeout: t}) => {
                clearTimeout(t),
                e(new Error("连接已断开"))
            }
            ),
            this.pendingRequests.clear()
        }
    }
    function p(a, e={}) {
        return new c(a,e)
    }
    class g {
        originalXHROpen = null;
        originalXHRSend = null;
        isHooked = !1;
        targetUrl = "/_/BardChatUi/data/batchexecute";
        targetAction = "hNvQHb";
        start() {
            this.isHooked || (this.hookXHR(),
            this.isHooked = !0)
        }
        stop() {
            this.isHooked && (this.unhookXHR(),
            this.isHooked = !1)
        }
        isGeminiAPIRequest(e) {
            return e.includes(this.targetUrl)
        }
        hasTargetRpcids(e, t) {
            try {
                return new URL(e,window.location.origin).searchParams.get("rpcids") === t
            } catch {
                return !1
            }
        }
        modifyFreqField(e) {
            try {
                const t = JSON.parse(e);
                let n = !1;
                const s = this.traverseAndModify(t, i => {
                    if (Array.isArray(i) && i.length >= 2 && i[0] === this.targetAction && typeof i[1] == "string")
                        try {
                            const r = JSON.parse(i[1]);
                            Array.isArray(r) && r.length > 1 && typeof r[1] == "number" && r[1] <= 20 && (r[1] = 100,
                            i[1] = JSON.stringify(r),
                            n = !0)
                        } catch {}
                    return i
                }
                );
                return n ? JSON.stringify(s) : e
            } catch {
                return e
            }
        }
        traverseAndModify(e, t) {
            if (Array.isArray(e))
                return e.map(n => {
                    const s = t(n);
                    return this.traverseAndModify(s, t)
                }
                );
            if (typeof e == "object" && e !== null) {
                const n = {};
                for (const [s,i] of Object.entries(e))
                    n[s] = this.traverseAndModify(i, t);
                return n
            }
            return e
        }
        modifyRequestBody(e) {
            if (!e)
                return e;
            if (typeof e == "string" && e.includes("f.req="))
                try {
                    const t = new URLSearchParams(e)
                      , n = t.get("f.req");
                    if (n) {
                        const s = this.modifyFreqField(n);
                        return t.set("f.req", s),
                        t.toString()
                    }
                } catch (t) {
                    console.error(t)
                }
            return e
        }
        hookXHR() {
            this.originalXHROpen = XMLHttpRequest.prototype.open,
            this.originalXHRSend = XMLHttpRequest.prototype.send;
            const e = this;
            XMLHttpRequest.prototype.open = function(t, n, s, i, r) {
                return this._interceptor_url = n,
                e.originalXHROpen.call(this, t, n, s !== !1, i || null, r || null)
            }
            ,
            XMLHttpRequest.prototype.send = function(t) {
                const n = this._interceptor_url;
                if (n && e.isGeminiAPIRequest(n) && e.hasTargetRpcids(n, e.targetAction)) {
                    const s = e.modifyRequestBody(t);
                    if (s !== t)
                        return e.originalXHRSend.call(this, s)
                }
                return e.originalXHRSend.call(this, t)
            }
        }
        unhookXHR() {
            this.originalXHROpen && (XMLHttpRequest.prototype.open = this.originalXHROpen),
            this.originalXHRSend && (XMLHttpRequest.prototype.send = this.originalXHRSend)
        }
    }
    const m = l( () => {
        p("inject-chat-web", {
            allowedIds: ["saveai-extension-content"]
        }).handle("getGeminiGlobalData", () => window.WIZ_global_data);
        const e = () => {
            const s = new g;
            s.start(),
            window.addEventListener("beforeunload", () => {
                s.stop()
            }
            )
        }
        ;
        ["https://gemini.google.com"].some(s => document.URL.includes(s)) && e()
    }
    );
    function y() {}
    function d(a, ...e) {}
    const f = {
        debug: (...a) => d(console.debug, ...a),
        log: (...a) => d(console.log, ...a),
        warn: (...a) => d(console.warn, ...a),
        error: (...a) => d(console.error, ...a)
    };
    return (async () => {
        try {
            return await m.main()
        } catch (a) {
            throw f.error('The unlisted script "inject-web" crashed on startup!', a),
            a
        }
    }
    )()
}
)();
injectWeb;
